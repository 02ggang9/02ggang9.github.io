---
title:  "JPA - OSIV에 대해서 알아보자(미완 초안)"
categories:
  - JPA
---

## 트랜잭션 범위의 영속성 컨텍스트
순수한 J2Se 환경에서 JPA를 사용하면 개발자가 직접 엔티티 매니저를 생성하고 트랜잭션도 관리해야 함. 하지만 스프링 같은 환경에서는 스프링 컨테이너가 제공하는 전략을 따라야 한다.

### 스프링 컨테이너의 기본 전략
스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. 말 그대로 트랜잭션 범위랑 영속성 컨텍스트가 유지되는 생존 범위가 같다. (p.578쪽 참고)

트랜잭션 시작하면 영속성 컨텍스트가 생성되고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다. 그리고 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

호출한 메서드가 시작하기 전에 트랜잭션 AOP가 먼저 작동함. 메서드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다. 트랜잭션을 커밋하면 영속성 컨텍스트를 플러쉬하고 데이터베이스에 반영후에 데이터베이스 트랜잭션을 커밋한다.

따라서 영속성 컨텍스트의 변경 내용이 데이터베이스에 정상 반영된다. 예외가 발생하면 트랜잭션을 롤백하고 종료함. 이때는 플러시 호출을 하지 않는다. (p.579)

1. (AOP 공부, 데이터베이스 트랜잭션 vs jpa 트랜잭션? 차이점 공부, 먼 말인지 잘 모르겠음 ㅎ.ㅎ)

2. (같은 트랜잭션에 있으면 같은 영속성 컨텍스트를 사용하는데 트랜잭션 전파 설정이 디폴트면 트랜잭션에 참여하게 되는데 이러면
같은 영속성 컨텍스트를 사용하는건가? 내 예상은 맞는거 같은데 그럼 테스트 코드에서 실패한 이유를 아직 잘 모르곘음..)

3. (현모 선배님께서는 테스트 코드에 달려있는 트랜잭션은 OSIV가 꺼져있다고 하시는데 이것도 한번 찾아봐야 할듯)

트랜잭션이 다르면 다른 영속성 컨텍스트를 사용함. 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. 스프링 컨테이너는 스레드 마다 각각 다른 트랜잭션을 할당한다. 그래서 멀티 스레드 상황에서 안전하다.


## 준영속 상태와 지연로딩
준영속 상태에서 지연로딩을 하게 되면 예외를 발생시킨다. 변경 감지 기능은 영속성 컨텍스트가 살아 있는 서비스 계층까지만 동작하고 영속성 컨텍스트가 종료된 프리젠테이션 계층에서는 동작하지 않는다.

해결하는 방법은 
1. 뷰가 필요한 엔티티를 미리 로딩해두는 방법
2. OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법

1. 방법
글로벌 페지 전략 수정 -> 이건 ㄴㄴ 지연로딩 말고 즉시 로딩 사용하겠다는 말이다.
JPQL 페치조인 
-> 한번에 다 끌어떙겨 오겠다. N+1 문제 해결가능하면서 프록시 객체가 아니라 실제 데이터를 가져옴
무분별하게 사용하면 화면에 맞춘 레포지토리 메서드가 증가할 수 있음. 물리적으로 분리되어있으나 논리적으로는 프리젠테이션 계층이 데이터 접근 계층을 침범하는거임

(약간 API 성능 최적화 할 때 V4, V5 느낌임)

강제로 초기화 
-> order.getMember() 여기까지만 하면 아직 프록시 객체가 담겨있는데 order.getMember().getName() 이렇게 하면 실제 데이터 값이 담김.

하이버네이트를 사용하면 initialize() 메서드를 사용해서 프록시를 강제 초기화할 수 있음. 근데 이렇게 되면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다. 이말은 뷰 계층이 서비스 계층에 침범한다는 의미이다.

계층 침범을 막기위해서는 FACADE 계층을 추가할 수 있음. 얘는 단순 프록시 초기화 역할만 담당함.(그림 p.591) 뷰와 서비스의 의존관계를 분리할 수 있음. 그리고 프록시 초기화해야해서 트랜잭션의 시작을 FACADE 게층에서 시작해야함. KEEPER는 서비스 계층에서 항상 시작하기 때문에 먼가 좀 이질감 듬. (사실 OSIV 쓰기때문에 상관 ㄴㄴ)

근데 위에 계층을 추가하면 추가작업이 있어서 조금 노가다 뛰는 기분임. 코드를 더 많이 작서해야함. 그리고 그냥 단순 서비스 계층을 호출만 하는 위임 코드가 잔뜩 있을것임.


2. OSIV 사용
OSIV -> Open Session in View 말 그대로 뷰 계층까지 영속성 컨텍스트를 열어둔다는 거임. 따라서 뷰 계층에서도 영속성 컨텍스트가 살아있기 때문에 지연로딩 가능. 키퍼도 지금 OISV가 default값으로 설정되어있음.(켜져 있다는 뜻)

### 과거 OSIV
OSIV의 핵심은 뷰 계층에서도 지연로딩을 가능하도록 하는 것임. 가장 단순한 구현은 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날때(response가 나갈때) 트랜잭션도 끝내는거임(그림 p.594)

이렇게하면 트랜잭션 범위 = 영속성 컨텍스트 생존 범위이기 때문에 영속성 컨텍스트가 살아있고 지연로딩을 사용할 수 있게 됨. 

근데 문제점이 있음.
트랜잭션도 필터까지 범위를 펼치기 때문에 단순 지연로딩도 사용이 가능하지만 수정이 가능함(더티 체킹) 의도치 않게 변경해서 예상과는 다르게 회원의 정보를 변경할 수 있음. 숨겨진 장애 발생 가능

위의 예상치 못한 수정을 해결할 수 있는 방법은 아래와 같다
1. 엔티티를 읽기 전용 인터페이스로 제공
2. 엔티티 래핑
3. DTO만 반환

1,2 는 뭔가 손에 잘 안맞음. 전통적으로 DTO를 반환하는게 많이 쓰인다. 키퍼도 그럼.

근데 3번 방법은 OSIV의 장점을 잘 못살린다고 함. 엔티티를 거의 복사한 듯한 DTO 클래스도 하나 더 만들어야 함.

위에 방법은 전부 다 코드의 양을 상당히 키움. 차라리 view 계층에는 엔티티 수정을 금지하도록 개발자들끼리 합의하는게 더 좋을 수 있음. 아니면 적절한 도구를 사용해서 setter를 잡아내는거임.

### 스프링 OSIV: 비즈니스 계층 트랜잭션
스프링 프레임워크가 제공하는 OSIV 라이브러리

하이버네이트 OSIV 서블릿 필터, 하이버네이트 OSIV 스프링 인터셉터, JPA OEIV 서블릿 필터, JPA OEIV 스프링 인터셉터

스프링 프레임워크가 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV임. 트랜잭션의 범위를 인터셉터 필터까지 펼치지 않고 비즈니스 계층으로만 한정함. 근데 영속성 컨텍스트는 인터셉터 필터까지 가져감. 따라서 뷰 계층에서도 지연로딩을 사용할 수 있지만 변경, 더티체킹으로 인한 수정은 불가능함.

요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성함. 이때 트랜잭션이 시작하지는 않음. ->
서비스 계층에서 트랜잭션 어노테이션으로 트랜잭션을 시작할 때 1번에서 미리 생성한 영속성 컨텍스트를 찾아와서 트랜잭션을 시작함. ->
서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시함. 이때 트랜잭션은 끝나는데 영속성 컨텍스트는 종료 x ->
영속성 컨텍스트가 유지되므로 영속 상태를 유지할 수 있음 ->

### 트랜잭션 없이 읽기
트랜잭션 없이 엔티티를 조회할 수 있음. 
영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있음.
트랜잭션 범위 밖에서는 엔티티를 조회할 수는 있지만 수정할 수는 없음. 이걸 트랜잭션없이 읽기(NoTransactional Reads)라 함. 과거 OSIV의 단점을 보안한 것이 특징임.

근데 주의사항이 있음
스프링 OSIV를 사용하면 프리젠테이션 계층에서 엔티티를 수정해도 수정 내용을 데이터베이스에 반영하지 않음. 근데 예외가 하나 있음.
프리젠테이션 계층에서 데이터를 수정하고 트랜잭션을 시작하는 서비스계층을 호출 해버리면 엔티티의 값이 변경될 수 있음. (그림 p.602)

프리젠테이션 계층에서 데이터를 변경하고 트랜잭션을 시작하는 서비스 계층의 메서드가 호출되고 아무런 데이터 값을 변경하지 않아도 프리젠테이션 계층에서 데이터를 변경했기 때문에 더티 체킹으로 엔티티의 값이 수정될 수 있음.


## 강의
WARN이 하나뜸. spring.jpa.open-in-view 가 디폴트로 설정되어있음.

OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지(response가 나갈때 까지) 영속성 컨텍스트와 데이터베이스 커넥션을 유지함. 트랜잭션이 시작할 때 데이터베이스 커넥션을 흭득함. 그리고 @트랜잭션이 끝나도 데이터베이스 커넥션을 계속 물고 있음. 그래서 View Template나 API 컨트롤러에서 지연 로딩이 가능했던 것임.

리스폰스가 나가면 데이터베이스 커넥션을 돌려주고 영속성 컨텍스트가 종료됨.

너무 오랫동안 데이터베이스 커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션은 커넥션이 부족할 수 있다. 커넥션이 말라버린다고 표현함. 결국 장애로 이어짐. 

만약 컨트롤러에서 외부 API를 호출하는게 있음. 그 외부API가 3초 걸리면 3초동안 물고있고 블로킹되면 스레드 풀 다 찰때까지 계속 먹는거임. 그래서 대기 시간동안 커넥션 리소스를 반환하지 못하고 유지해야함.


OFF해버리면 트랜잭션 범위랑 영속성 컨텍스트의 범위가 완벽하게 일치함. 이러면 데이터베이스 커넥션을 아주 짧게 가짐. 영속성 컨텍스트도 안쓰고 데이터베이스 커넥션도 안쓰기 떄문에 (커넥션 풀에 반환) 장애 발생이 잘 안남. 커넥션 리소스를 낭비하지 않음.

단점은 모든 지연로딩은 트랜잭션 안에서 처리해야 함. 그래서 지연 로딩 코드를 트랜잭션 안으로 다 끌어넣어야함.

(데이터베이스 커넥션 풀이 다 채워졌는지는 어떻게 알까? 찾아봐야 할 듯)


고객 실시간 서비스 API는 OSIV는 끄고, ADMIN처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 킴.





