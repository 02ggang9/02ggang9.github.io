---
title:  "Jpa - 컬렉션 조회 최적화(초안 미완)"
categories:
  - Jpa
---

# 컬렉션 조회 최적화

## V1 - 엔티티를 직접 노출

## V2 - 앤티티를 DTO로 변환
그러면 오? DTO도 반환도 했고 잘 도ㅒㅆ네요? -> 이러면 안된다.

(6분대)
계속 강조를 드리는데 DTO로 반환하라고 했었을 때 DTO안에 Entity가 있으면 안됨(래핑 하는것도 안됨)
엔티티가 외부에 노출됨. 단순하게 DTO하나 감싸서 보내라는게 아니라 완전히 엔티티하고 의존을 끊어야 한다.
다행히 KEEPER 코드에는 V2임에도 불구하고 엔티티하고 의존을 다 끊어 냈다!

페이징 slice로 팔로잉, 팔로워 가져오는 것도 괜찮을듯?


## V3 - 엔티티를 DTO로 변환 - 페치 조인 최적화
distinct?
db 의 distinct는 row 데이터 전부 다 같아야 없애줌. -> Spring boot 3버전 부터는 자동으로 중복을 제거해준다!
JPA 자체적으로 distinct가 있으면 Order가 같은 id 값이면 중복을 버려준다. 그리고 List에 담아서 넘겨준다.

-> 근디 페이징이 안됨 ㅠㅠ
리미트가 없음;; -> WARN 로그를 띄워주면서 firstResult/maxResult가 collection fetch랑 같이썻어! -> 메모리에서 페이징처리한다? -> 데이터 만 개가 들어왔으면 애플리케이션에 1만개 다 퍼올린다음에 메모리에서 처리하는거임 -> OUT OF MEMORY 나와야겠지?

그리고 DB에 쿼리 날렸을 때 DB SQL 입장에는 뻥튀기 되어있기 때문에 데이터 개수를 이상하게 맞춘다.

일 대 다 대 다 -> 이건 쓰지말라고 하시는데 그럼 우짬?

## V3.1 - 엔티티를 DTO로 변환 - 페이징과 한계 돌파
대부분의 페이징 + 컬렉션 엔티티 조회는 이 방법으로 해결할 수 있다. 코드도 단순하고 성능 최적화도 보장하는 매우 강력한 방법!

모든 ToOne 관계는 걍 fetch 조인 걸어라! 이건 ROW 수가 변경되지 않아서 한방에 가져올 수 있고 페이징 쿼리에 영향을 주지 않는다!
-> @BatchSize를 적용한다! (KEEPER는 이미 걸려있음!)

pk 기반으로 in 절을 날리기 때문에 엄청 빠르다!
1 : N : M -> 1 : 1 : 1 로 만들어 줄 수 있다.

V3의 문제 -> 데이터가 중복이 엄청 많음. ORDER 부분은 엄청 중복이 많음 USERNAME이 똑같거다 등등..
이걸 DB에서 애플리케이션에 다 보냄. 그니까 데이터 전송률이 높아진다. 

V3.1 -> 이 방식은 딱 최적화 되어서 나옴

## V4 - JPA에서 DTO 직접 조회
Setter를 쓴다? (14분대)

N + 1 문제가 발생한다!

## V5 - JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

in 절로 한방에 orderItem을 들고온다!

Map으로 바꾼다! -> groupBy로 Map으로 바꿀 수 있음.
세연님이 보내주신 쿠팡 고도화? 그 블로그에서 나왔던 코드랑 굉장히 유사하다!

## V6 - JPA에서 DTO로 직접 조회, 플랫 데이터 최적화

페이징 되긴 하는데 우리가 원하는 페이징은 안됨 
일대다 조인이기 때문에 뻥튀기 된다!


엔티티를 DTO로 변환하는 것은 배치 사이즈를 정하고 간단하게 join fetch 몇 줄 넣어서 간단하게 성능을 끌어올릴 수 있다.
하지만 DTO로 직접 조회하는 방법은 많은 코드를 변경해야 한다.

여기서 의문점이 생기는데 엔티티를 DTO로 변환하는 이 방식으로도 성능이 안나오는 경우면 데이터가 엄청 많다는 의미인데 이럴 때는 캐쉬나 등등을 써서 해결을 해야한다. 과연 DTO로 직접 조회해서 해결할 수 있을까?

엔티티는 직접 캐슁 하면 안된다. 무조건 DTO로 변환한 다음에 DTO를 캐싱해야 한다!

개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.

배치 사이즈를 이용하면 JPA가 알아서 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서 성능을 최적화할 수 있다. 

반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야 한다.

V4는 코드가 단순하고 이해하기 쉽다. 유지보수가 쉽고 단건 조회는 이 방식만 사용해도 성능이 잘 나온다.

V5는 loop를 돌면서 id 를 찍어서 가져옴(N+1) 문제 발생. order 10개 에 해당하는 id를 in절로 한번에 땡긴다음 메모리에 올려두고
재조립했다. N+1 -> 1+1 까지 쿼리의 수를 줄일 수 있다. 하지만 이 방식은 V4에 비해서 코드가 복잡하다. 근데 성능 차이는 100배 이상의 성능 차이가 날 수 있다.



## 키퍼 적용
V2 -> 12 번
V3.1 -> 3번
~~~java
    select
        m1_0.id,
        f2_0.followee,
        f2_0.id,
        f2_0.follower,
        f1_0.follower,
        f1_0.id,
        f1_0.followee,
        m1_0.generation,
        m1_0.is_deleted,
        m1_0.level,
        m3_0.member_id,
        m3_0.id,
        m3_0.member_job_id,
        m1_0.member_rank_id,
        m2_0.id,
        m2_0.badge_thumbnail_id,
        m2_0.name,
        m1_0.point,
        m1_0.birthday,
        m1_0.email_address,
        m1_0.login_id,
        m1_0.password,
        m1_0.real_name,
        m1_0.student_id,
        m1_0.thumbnail_id,
        m1_0.total_attendance      
    from
        member m1_0      
    join
        member_type m2_0              
            on m2_0.id=m1_0.member_type_id      
    join
        member_has_member_job m3_0              
            on m1_0.id=m3_0.member_id      
    join
        friend f1_0              
            on m1_0.id=f1_0.follower      
    join
        friend f2_0              
            on m1_0.id=f2_0.followee      
    where
        m1_0.id=25423
~~~

~~~java
    select
        m1_0.id,
        m1_0.generation,
        m1_0.is_deleted,
        m1_0.level,
        m1_0.member_rank_id,
        m1_0.member_type_id,
        m1_0.point,
        m1_0.birthday,
        m1_0.email_address,
        m1_0.login_id,
        m1_0.password,
        m1_0.real_name,
        m1_0.student_id,
        m1_0.thumbnail_id,
        m1_0.total_attendance      
    from
        member m1_0      
    where
        m1_0.id in(25425,25428,25429,25430,25426,25427)
~~~

~~~java
    select
        m1_0.id,
        m1_0.name      
    from
        member_job m1_0      
    where
        m1_0.id=9
~~~