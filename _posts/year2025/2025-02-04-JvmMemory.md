---
published: true
title: "자바의 메모리 구조와 코틀린의 Pair 클래스 성능 (JVM + Algorithm)"
---

## 서론

알고리즘 스터디를 진행하면서 골드 5이상의 문제를 처음 풀어봤는데 메모리 초과가 굉장히 많이 발생했습니다. 보통 실버문제들은 시간 제한이나 메모리 제한이 굉장히 널널하기 때문에 지금까지 이런 예외들은 생각하지 못했는데, 이번 기회에 정말 많이 배운 것 같습니다.


가장 인상깊었던 것은 코틀린에서의 Pair 객체 사용이였는데, 이 객체는 실버문제를 풀 때는 아무런 문제가 발생하지 않았습니다. 하지만 골드 문제들을 풀 때 Pair 객체를 사용하니까 매번 실패하고 IntArray 라는 자료구조로 풀어야만 문제를 통과했습니다. Pair 자료구조가 왜 메모리를 많이 잡아먹는지와 IntArray의 장점에 대해서 살펴보고 JVM 레벨에서 어떻게 메모리를 관리하는지 알아봤습니다.


## Pair 자료구조의 메모리 사용률과 IntArray 비교

Pair data class의 코드는 아래와 같습니다.

~~~java
public data class Pair<out A, out B>(
    public val first: A,
    public val second: B
)
~~~

Pair는 정말 간단하게 두 개의 제네릭 타입을 받고, 그 타입에 맞는 원소 값을 저장하는 간단한 래퍼 클래스입니다. 이 데이터 클래스는 코틀린으로 알고리즘 문제를 풀 떄 first를 X좌표, second를 Y좌표로 표시하면 굉장히 편하기 때문에 자주 사용했습니다. 특히 다익스트라 알고리즘을 사용할 때 많이 사용했는데, 이번에 성능 분석 툴인 VisutalVM을 통해 메모리 사용량을 분석해보니 굉장히 많은 메모리를 사용한다는 것을 알았습니다.


분석한 자료를 보기에 앞서, 먼저 자바의 원시타입과 래퍼런스 타입의 저장 공간 차이에 대해서 알아야 하는데 원시 타입은 stack 영역에 저장되고 래퍼런스 타입은 heap 영역에 저장됩니다. 래퍼런스 타입은 heap 영역에 저장된 주소 값을 stack 영역의 변수 값을 저장하는 것이고 원시 타입은 실제 값이 들어있는데 여기서부터 메모리 사용량의 차이가 발생합니다. 


배열은 heap 영역에 저장되게 되는데 위 개념을 가지고 다시한번 배열을 생각해보면 아래의 사진과 같습니다.

![](https://github.com/02ggang9/02ggang9.github.io/blob/master/_posts/year2025/JvmMemory1.png?raw=true)

원시 타입의 배열은 heap 영역에 연속적인 메모리로 저장되고 값이 저장되지만 래퍼런스 타입은 heap 영역에 연속적인 메모리로 저장은 되지만 값이 아니라 다른 인스턴스가 heap 영역 어딘가에 저장된 주소 값을 저장하고 있습니다. 이 그림을 보고 드는 생각은 레퍼런스 타입의 배열은 힙 영역에 인스턴스가 추가로 생성된다는 것과 배열 안의 "값"에 접근하기 위해서는 한번 더 참조를 해야 함으로 시간이 더 오래 걸린다는 정도입니다.


지끔까지 알아본 개념으로 Array<IntArray>와 Array<Pair<Int,Int>>의 메모리 사용량을 생각해 볼 수 있습니다. 코틀린의 IntArray는 원시 타입의 배열이 생성되고 Array<Pair<Int, Int>>는 Pair 객체 안에 두 래퍼런스 타입이 저장됩니다. 머리속에 그림을 그려보면 얼마나 차이나는지 알 수 있는데 저는 실제로 얼마만큼의 메모리가 사용되는지 수치화를 하고 싶어 visualVM 이라는 분석 툴로 비교를 해 봤습니다.


![](https://github.com/02ggang9/02ggang9.github.io/blob/master/_posts/year2025/JvmMemory2.png?raw=true)


![](https://github.com/02ggang9/02ggang9.github.io/blob/master/_posts/year2025/JvmMemory3.png?raw=true)

위의 첫번째 사진에서 볼 수 있듯이 IntArray로 선언한 코드는 원시 타입의 배열이 생성되었고 총 461,546개가 생성되었고, 메모리 사용량은 11,114,864 Byte가 사용되었습니다. 두 번째 사진은 Pair<Int, Int> 배열로 선언한 코드의 사진인데, Pair 객체가 280,747개가 생성되었고 메모리는 6,737,928 Byte가 사용되었습니다. 또, 추가적으로 Integer 인스턴스가 총 561,501개가 생성되었고 메모리는 8,984,016이 사용되었습니다.

이 수치를 가지고 GPT에게 물어보니 같은 데이터 수를 저장한다고 가정했을 때 길이가 2인 IntArray는 약 24Byte, Pair + 2 * Integer 객체는 약 56Byte를 사용하게 되므로 약 2.3배 정도의 메모리 차이가 난다고 합니다. 이러한 이유 때문에 코틀린으로 푼 알고리즘 문제에서 계속해서 메모리 초과가 발생하였고 IntArray를 사용해서 무사히 통과할 수 있었습니다.


## 자바의 메모리 구조


## 결론


## 수정사항

2025.02.04 : 서론, Pair 자료구조의 메모리 사용률과 IntArray 작성
