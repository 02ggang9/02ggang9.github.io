---
published: true
title:  "Programing Language - 프로그래밍 언어의 발전사: 언어를 선택하지 말라"
categories:
  - etc
---

## 서론

시험기간에 글을 쓰는 것은 자살행위라고 생각하지만, 시험공부만 하니까 정신이 붕괴되는 것 같았습니다. 프로그래밍 언어론이 재밌는 것인지, sigmaDream 교수님의 수업이 재미있는 건지는 잘 모르겠지만(아마 후자인 것 같습니다) 어쨋든 재미있어서 글을 써 봤습니다. 

[제 BDD 소개글](https://chip-force-ed0.notion.site/59cdcd35ee6f40009ba780a996fb0dcd?pvs=4)을 보면 코틀린과 센디를 좋아한다고 설명이 되어 있습니다. 코틀린을 좋아했던 이유는 언어적인 특징에 이끌려서가 아니라 그냥 힙 해 보여서 그랬었습니다. 하지만 프로그래밍 언어론 수업을 듣고 끌리는 언어 하나를 선택하는 것이 아니라 시대의 흐름이 어떻게 흘러가고 그 시대에 맞는 언어를 선택해야 한다는 것을 알았습니다. 수업 시간에 정말 방대한 양의 정보를 입력받았는데, 글로 잘 풀어낼 수 있을지 모르겠네요! 대표적인 언어 C++의 발전사를 살펴보고 지금 어떤 시대에 살아가고 있는지 알아보도록 하겠습니다.

## C++ 언어의 발전사

### C++98 ~ C++03

제가 지금 C 언어를 배우고 있는데, C99 버전을 사용하고 있습니다. sigmaDream 교수님께서 말씀하시기로 현재 업계에서는 C99을 사용한다고 합니다. 업계가 C99을 사용하기 때문에, C11을 배워도 사용할 수 없습니다. C언어는 임베디드 같은 것들에 사용해야 하니까 메모리 세이프한 것에 동의하지 않습니다. 임베디드는 메모리를 위험하게 핸들링해도 좋으니까, 좋은 성능을 요구받게 됩니다. C는 오로지 성능만을 쫒아 다닙니다.

포인터와 레퍼런스를 다 가지게 되는 언어가 탄생하게 되는데 그 언어를 C++이라고 부릅니다. 하지만 C++을 공부할 때 포인터와 레퍼런스 둘 다 사용할 수 있는 자유도를 주지만, 포인터는 쓰지말라고 그렇게 얘기합니다. 레퍼런스를 제발 써달라고 합니다.

C++98과 C++03은 레거시 C++이라고 부르는데, C++03은 C++98에 Bjarne Stroustrup가 쓴 ARM(Annotated C++ Reference Manual)을 참고해서 만든 버전입니다. 이때 STL(string, stream, algorithms, etc..)가 들어오게 됩니다. 그리고 2003년에 대 웹의 시대가 열리게 됩니다. 웹이 뜨면서 메모리 안정성을 요구받기 시작합니다. C언어로는 도저히 서비스를 유지할 수 없었습니다. 포인터 잘못 찍으면 바로 죽어버리기 때문입니다.
### TR1

메모리 안정성을 위해 TR1에는 스마트 포인터(shared_prt)이 들어오고, 해킹을 방어하기 위해 난수(random)이 들어오기 시작합니다. 또, 정규식, 해쉬 등이 들어오게 됩니다. C++은 레퍼런스 사용을 권장하지만 스마트 "포인터"가 들어왔습니다. 왜냐하면 C++ 개발자들이 레퍼런스를 안 쓴다는 것을 깨달았기 때문입니다. 

웹 시대에 메모리 안정성이 무척 중요해졌는데, C++은 메모리 안정성을 보장하기 위한 것들이 너무 늦게 들어와 모든 권력을 Java와 C#으로 이양하게 됩니다.

### C++11

C++11에는 move-semantic, atomic, threading이 들어오게 됩니다. C++은 기본적으로 매개변수를 전달할 때, 딥 카피를 뜰 것인지, 쉘로우 카피를 뜰 것인지 개발자가 결정해야 하는데, 무브 시멘틱을 사용하면 좀 더 빠르고 안전하게 쓸 수 있게 해줍니다.

메모리를 안전하게 쓰고 싶어? -> 스마트 포인터 사용해 -> 스마트 포인터 쓰면 무브 시멘틱 사용할 수 있어 -> 그러면 딥 카피 빠르게 해줄게 라는 구조를 C++11이 만들게 됩니다. 또, 다코어 CPU가 들어오니까 atomic과 threading이 들어왔습니다.

### C++14

C++14에는 메모리를 더 안전하게 복제할 수 있도록 read-write lock이 생겼고, 메모리를 파괴하지 않고 어떤 값을 만들어서 계산 결과로서 프로그래밍을 이어나갈 수 있도록 람다가 들어오게 됩니다. 

sizeOf를 니가 잡지 마! 그래야 컴파일러가 락을 잡아 -> 락을 컴파일러가 잡아야 아토믹을 넣고, 아토믹을 넣어야 스레드를 넣을 수 있어 -> 스레드를 넣어야 무브 신텍스 할 때 계산이 빨라져 라는 논법이 만들어지고 C++은 불살라집니다. 너무 어렵습니다. (자바 개발자인 저는 옆의 논법을 1도 이해하지 못 했습니다)

### C++17, C++20

C++17은 자바에서 보던 optional이 들어오고, any, variant 등이 들어옵니다. C++20은 코루틴이 들어오죠. 14부터 망했던 C++을 17, 20이 먹여 살립니다. 다코어 시대에 들어오면서 비동기 프로그래밍이 주류가 되면서 한방에 떠버렸습니다. 4년간의 기다림 끝애 빛을 본겁니다.

## 모든 언어는 시대를 거스를 수 없다

모든 언어는 시대를 거스를 수 없습니다. 자바도 JDK 21 (정확히는 19)에 Virtual Thread가 들어왔습니다. 다른 언어들도 코루틴이 들어오고 있고, JDK 22에는 벡터 API가 들어올까 말까 하고 있습니다. 자바도 다코어 시대에 맞게 지원하려고 합니다.

### 코틀린은?
[Kotlin 2.0.0-RC1](https://kotlinlang.org/docs/whatsnew-eap.html)
코틀린은 독고다이 입니다. 뭔가 이상합니다. 코틀린은 다음과 같이 말합니다. "저희는 타입 체크를 좀 해야겠어요", "저희는 exception handling을 더 하겠습니다", "스마트 캐스트 버그 고치겠습니다!"라고 합니다. 스레드 먼지 잘 모르겠고, 타입 안정성이나 확보하렵니다. 

코틀린은 지금 멀티 플랫폼에 운을 걸었습니다. 타입 체킹을 완벽하게 해서 IOS 웹 안드로이드나 다른 PC 플랫폼에도 완벽하게 호환되게 하려고 합니다.

수업 시간에 정말 많이 들었는데, 우리는 언어 하나를 선택하지 말고 시대에 맞게 언어를 선택해야 합니다. 그 언어가 무엇에 중점을 두고 발전하고 있는지 정도를 파악하고 있어야 합니다. 수업을 듣기 전 제가 사용하고 있는 네이티브 언어가 어떤 것을 바라보고 발전하는지 관심이 없었지만, 오늘부터 틈틈이 앞으로의 발전 과정을 살펴보겠습니다.


## 결론
언어 하나를 선택하지 말고, 시대에 맞는 언어를 선택해라.

