# 프록시

프록시 초안입니다. 머리속에 있는 내용 쭉 적어보기

## 프록시란
비유하자면 프록시는 대리자입니다. 만약 어머니께서 장보라고 말씀을 하시면 동생을 시키던지 할 수 있습니다. 그럼 동생이 대리자이고 프록시 입니다. 


## 프록시가 필요한 이유


메인 기능을 하는 클래스가 부가 기능을 하는 클래스의 존재를 모르면 좋겠을 때 필요합니다. 키퍼 프로젝트로 예를 들어 세연님께서 만들어 주신 API 성능 측정기를 예시로 들겠습니다. 모든 API가 이 기능을 하는 클래스의 존재를 알아야 할까요? 그렇게 하려면 모든 메서드에 이 부가 기능을 하는 코드를 집어 넣어야 합니다. 이렇게 하면 메인 클래스가 부연 클래스의 존재를 알게 됩니다.

이러한 문제를 해결하고자 하면 부가 가능을 하는 메서드가 메인 메서드를 호출하도록 하면 됩니다. 그렇게 된다면 메인 메서드는 부가 메서드에 대한 존재를 모르게 할 수 있습니다.

## 프록시 패턴 VS 데코레이터 패턴
두 개의 차이점은 패턴이 가지는 의도를 통해서 구분할 수 있습니다. 프록시 패턴의 의도는 접근을 제어하기 위함이고 데코레이터 패턴의 의도는 부연 기능을 사용하기 위함입니다.

패턴의 구조는 아래의 사진과 같습니다.

두 개의 패턴의 구조는 똑같고 위에서 말씀드린대로 의도에 따라서 패턴을 구분할 수 있습니다. 키퍼 프로젝트에서 예를 들면 세연님이 만들어주신 API 성능 측정기는 나간 쿼리의 개수, 시간 등을 포맷팅해서 출력해주기 때문에 데코레이터 패턴이라고 할 수 있고 저희가 지연 로딩을 사용할 때 영속성 컨텍스트가 죽었을 때 접근을 제어하기 위한 것은 바로 프록시 패턴이라고 표현할 수 있습니다(사실 이 부분은 좀 더 찾아봐야함. 과연 프록시 패턴이 맞을까? 다른 예시는 있을지 생각해보자)

## 구조는 어떻게 만들어야 하나?
아래의 사진처럼 클라이언트가 인터페이스에 의존하도록 설정하고 메인 클래스는 인터페이스를 상속하도록 설계하면 됩니다. 그리고 프록시 또한 같은 인터페이스를 구현하면 됩니다. 이렇게 할 경우 클라이언트는 인터페이스만 의존하기 때문에 자기가 메인 클래스를 사용하는 줄 알지만 사실은 프록시를 사용해 메인 기능을 호출하도록 만들 수 있습니다.

### 문제점
만약 여러가지의 부가 기능이 있다면 다 한 개의 인터페이스를 구현하도록 해야하고 여러 개의 인터페이스가 있다면 또 다 구현해야 합니다. 코드의 양이 똑같이 증가하는 문제점이 생깁니다.

이 문제점을 해결하기 위한 방법은 바로 리플랙션과 JDK 동적 프록시가 있습니다.


# 다시
핵심기능을 하는 코드와 부가 기능(데코레이팅)을 하는 코드가 있다고 했을 때 보통 핵심 기능을 끝마치고 나온 결과로 부가 기능을 통해 데코레이팅을 하게 됩니다. 이렇게 하면 부가 기능의 구체적인 구현 코드는 제거했을지라도 위임하는 코드는 남아 있게 됩니다. 

그리고 부가 기능이 많아지고 여러 핵심 기능에 적용을 해야 한다면 코드는 지저분해지고 부가 기능을 적용해야 한다는 사실은 코드에 남아있게 됩니다.

핵심기능이 부가 기능을 가진 클래스의 존재 자체를 모르게하려면 어떻게 해야 할까요?

바로 부가 기능이 핵심 기능을 사용하는 구조로 변경하면 핵심기능은 부가 기능을 가진 클래스의 존재를 모르게 할 수 있습니다. 그런데 클라이언트가 핵심 기능을 바로 사용해버리면 부가 기능을 적용할 수 없게 됩니다. 이런 문제점을 방지하기 위해서 부가 기능은 핵심 기능의 인터페이스를 구현한 뒤 클라리언트는 인터페이스에 의존하도록 설정하고 프록시는 클라이언트와 핵심 기능 사이에 위치하도록 하게 하면 됩니다. 이 부가 기능이 바로 프록시 입니다.

프록시: 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자(Proxy)(p.430)


## 데코레이터 패턴 vs 프록시 패턴
데코레이터 패턴과 프록시 패턴의 구조는 위에서 본 사진과 동일합니다. 이 둘의 차이점은 바로 "의도"입니다. 데코레이터 패턴의 의도는 부가적인 기능을 부여해주기 위한 의도를 가지고 있고 프록시 패턴의 의도는 접근 제어를 하기 위한 의도를 가지고 있습니다.

프록시 패턴 ->  -> 캐시 ()
만약 데이터가 한번 조회하면 변하지 않는 데이터라면 어딘가에 보관해두고 이미 조회한 데이터를 사용하는 것이 좋다 이를 캐시라고 한다.
처음 client -> 1초 -> 캐시 0초 -> 캐시 0초
~~~java
예시 코드
~~~




데코페이터 패턴 -> 세연님이 작성해주는 API 성능 측정기


클라이언트의 코드 변경없이 자유롭게 프록시를 넣고 뺄 수 있습니다. (사실 잘 모르겠음 new 이런 것들은 바꿔줘야 하는 거 아닌가?)
클라이언트는 실제 객체가 주입되었는지 프록시 객체가 주입되었는지 모르게 됩니다.

