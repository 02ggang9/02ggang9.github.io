---
published: false
title:  "Effective Java Item1 - 생성자 대신 정적 팩터리 메서드를 고려하라(초안 미완)"
categories:
  - Java
---

## 열거 타입

Enum 장점 -> 특정한 값을 제한할 수 있다(필드가 가질 수 있는 값) -> Type Safety
Enum이 없었다면 int 값을 쓰거나 메모리를 더 적게 쓰는 char, short를 썻을 것이다. 또는 문자열
근데 문자나 숫자의 문제점은 
0 - 주문받음
1 - 준비 중
2 - 배송 중
3 - 배송 완료

만약 status에 100이 들어가거나 200이 들어가는 경우는 어떻하냐? -> 왜냐하마녀 int 범위에 포함되기 때문이다.
그래서 이러한 검증, 방어하는 코드를 작성해야함

근데 Enum을 쓰면 컴파일 차원에서 제공하기 때문에 다른 값들이 들어갈 수 없음. 오직 orderStatus가 제공하는 값들만 사용할 수 있음
singleton 을 안전하게 쓰는 방법 -> Enum을 사용하는 방법이 있음 

Q1. Enum 타입을 가질 수 있는 모든 값을 순회하면서 출력하는 방법은?
values()를 알고있느냐? 를 묻는 질문이였다.

Q2. 자바의 Enum은 생성자와 메서드 필드를 가질 수 있는가?
Enum을 쓰지만 Enum 내부적으로 필드랑 메서드를 가져야 하는 경우도 있다.
PREPARING(0), SHIPPED(1) 등등.. DB에 저장할 때 문자열 그대로 저장하는게 아니라 DB에 숫자로 저장하겠다.
이름이 바뀌더라도 숫자를 그대로 유지할 수 있게끔..

Q3. Enum은 == 연산자로 비교를 할 수 있는가?
== 쓰는걸 권장을 한다. 어짜피 JVM 레벨에서 하나의 인스턴스만 있음을 보장하기 때문에 equals를 쓸 필요가 없다.
그리고 nullPointException이 발생할 수 있는 확률이 있다. 그래서 그냥 ==을 써라!
(사진 또는 코드 참고)

Q4. Enum을 키로 사용하는 Map 또는 Enum만을 담고 있는 Set을 선언하고 시을 때 또는 만들어서 쓰고 싶을 때 어떻게 하면 좋겠나?
EnumSet과 EnumMap을 써야한다.

일반적인 Set이나 Map으로 HashMap, 등을 쓰면 틀린거임 -> Enum만을 담고 있으면 EnumSet과 EnumMap을 쓰는게 훨씬 좋고
훨씬 빠르다.

이거는 숙제고 왜 EnumMap을 사용하는게 좋은지 질문 게시판에 남길 것!!

## 플라이웨이트 패턴

같은 객체가 자주 요청되는 상황에 플라이웨이트 패턴을 사용할 수 있다.
같은 객체가 자주 사용된다 -> 같은 객체를 어딘가에 저장했다가 가져다 쓰면 좋지 않을까? 아니면 캐쉬를 사용하는게 좋지 않을까?

플라이웨이트 패턴은 객체를 다시 사용하는 방법이다.

플라이웨이트 -> 객체를 가볍게 만들기 위한 패턴, 복싱 체급에 쓰이는 용어이기도 함(가벼운 무게)
자주 변하는 속성과 변하지 않는 속성을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.
(사진 참고)

## 인터페이스와 정적 메서드
자바 8과 9에서 주요 인터페이스 변화

자바 8의 인터페이스에서는 메서드를 정의할 수 없다. default, static 메서드 둘 중 하나를 선택해야 한다.
(기본 메서드, 정적 메서드)

자바 9의 인터페이스에서는 private를 사용할 수 있다.
매번 public으로 공개해야 하네? 공개하고 싶지 않은데? 싶어서 만들었다. 내부적인 용도로 사용하기 위해 만들어졌음

인스턴스와 불가 동반 클래스를 둘 이유가 없어진다.
(private, final) Helper나 util을 많이 만들었는데 만들 이유가 많이 줄어들었다. 그럼에도 있는 경우는 
default나 이런 것들로 해결할 수 없는 문제가 조금 남아있기 때문이다. 인스턴스는 필드를 가질 수 없음.
private한 필드를 가질 수 없기 때문에 private 필드를 사용하는 Helper나 util을 만들려고 하면 인터페이스에서 쓰는 default나 이런것들을 사용할 수 없기 때문에 Helper를 사용해서 해결해야 한다.

Q1. 내림차순으로 정렬하는 compare operator를 정의하고 숫자 리스트를 정렬해보는 코드를 작성해봐라!
Compareator
(그림 참고)

Q2. 위에서 만든 desc comparator는 그대로 두고 오름차순으로 정렬하는 코드를 작성해봐라!
만약 reversed()를 썻다면 아마도 공부를 잘 한거임!

## 서비스 제공자 프레임워크

확장 가능한 애플리케이션을 만드는 방법

애플리케이션의 코드는 그대로 유지되면서 외적인 요인을 변경했을 때(코드를 변경하지 않고) 애플리케이션의 동작을 바꿀 수 있을 때
확장 가능하다고 한다.

실제 콘솔에만 출력하는 문자를 설정을 바꿨다고 이메일에 전달하거나 디비에 저장할 수 있는게 예시임 ㅇㅇ;

Spring을 사용하는 예

HelloService -> 서비스 제공자 인터페이스 

브릿지 패턴?
서비스 로더?

## 리플렉션

책에서 잠깐 제공됨. 
리플렉션 -> 일상생활에서 잘 안쓰임. 거울에 반사된 이미지를 반사, 투영이라고 표현할 수 있겠다.
반영된 이미지를 보고 

프로그래밍 적으로 무엇이 어디에 반사가 되어있는것인가?
클래스의 정보느느 classLoader가 읽어들인다(JVM에서) 해당 정모를 메모리 어딘가에 둔다. 정보가 곧 거울에 비친 우리의 모습이라고 할 수있다.

대부분의 정보들이 거기에 담겨 있음.

EX) 애노테이션 정보를 읽어들이는 거임. 거울에 비춘 모습을 보고 안경을 썻는가? 확인하는거랑 비슷함.




