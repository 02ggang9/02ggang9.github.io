---
published: true
title:  "Kotlin Generic - Generic 공부 및 정리(1)"
categories:
  - Java
---

## 서론

Generic을 실무에서 작성할 일은 그렇게 많이 없을 것 같습니다. 하지만, 우리가 정말 많이 사용하고 있는 List 등 다양한 자료구조가 제네릭으로 작성되어 있습니다. 또, 평소 OOP 철학을 가지고 코드를 작성하지만 제네릭 없이는 객체 지향적으로 코드를 작성하기에는 무리가 있어 보였습니다. 이 외에도 정말 많은 이유들로 인해서 제네릭을 공부해봤고, 어느정도 감은 잡았지만 막상 코드를 짜려고 하니 정말 많이 버벅거렸습니다. 교수님께서 말씀하시기로 제네릭은 대부분 버벅거린다고 하셨습니다. 우리의 잘못이 아니라, 제네릭은 평소 의식하면서 수련하지 않으면 늘지 않기 때문입니다. 

아래에서 제네릭과 제네릭 제약, 변성에 관해서 알아보고 제어 구문을 밖으로 드러내는 방법에 대해서 알아보도록 하겠습니다.


## 제네릭

> 지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거움을 줄인다. - 자바의 정석 p.670


### 코드 재사용(타입 파라미터)

~~~java
class IntegerBox(
    private var value: Int
) {

    fun set(value: Int) : Unit {
        this.value = value
    }

    fun get(): Int {
        return this.value
    }

}
~~~

~~~java
class StringBox(
    private var value: String
) {

    fun set(obj: String) : Unit {
        this.value = obj
    }

    fun get() : String {
        return this.value
    }

}
~~~

~~~java
fun main() {
    val integerBox = IntegerBox(10)
    integerBox.set(20)
    val integer = integerBox.get()
    println("integer = ${integer}")

    val stringBox = StringBox("HI")
    stringBox.set("Hello")
    val str = stringBox.get()
    println("str = ${str}")
}
~~~

위의 코드에 문제점은 구체적인 타입에 의존하기 때문에 DoubleBox 등 다양한 타입의 Box가 늘어날 때마다 중복되는 코드를 작성해야 한다는 점입니다. 이와 같은 문제를 제네릭을 사용하면 손쉽게 해결할 수 있습니다.

~~~java
class Box <T> (
    private var value : T
) {

    fun set(obj : T) : Unit {
        this.value = obj
    }

    fun get() : T {
        return this.value
    }
}
~~~

~~~java
fun main() {
    val box = Box<Double>(10.0)
    box.set(20.0)
    val boxValue = box.get()
    println("boxValue = ${boxValue}")
}
~~~

### 타입 안정성(제네릭 제약)

~~~java
class Cage2 <T> {

    private val animals: MutableList<T> = mutableListOf()

    fun getFirst(): T {
        return animals.first()
    }

    fun put(animal: T) {
        this.animals.add(animal)
    }

    fun moveFrom(cage: Cage2<T>) {
        this.animals.addAll(cage.animals)
    }
}
~~~

~~~java
fun main() {
    val intCage = Cage2<Int>()
    val strCage = Cage2<String>()
}
~~~

현재의 Cage2 제네릭 클래스는 T 타입에 아무런 제약을 걸고 있지 않습니다. 이렇게 될 경우 위의 main 함수처럼 Animal의 하위 타입이 아닌 Int, String 같은 다양한 타입들이 밀고 들어올 수 있습니다. 이런 문제를 해결하기 위해서 제네릭 제약(Generic Constraints)를 필수적으로 걸어야 합니다. 또, 다른 이유는 컴파일 시점에 T 값에 어떤 값이 들어올지 예측할 수 없어서 Object가 제공하는 메서드만 호출할 수 있는데 이는 뒤에서 살펴보도록 하겠습니다.

~~~java
// 수정 후 
class Cage2 <T : Animal>

fun main() {
    val intCage = Cage2<Int>() // Type argument is not within its bounds.
    val strCage = Cage2<String>() // Type argument is not within its bounds.
}
~~~

Animal 포함 하위 클래스만 오도록 설정함으로써 컴파일 시점에 타입 에러를 잡아낼 수 있습니다. 만약에 T 타입 매개변수 제한을 걸지 않고 열어둔다면, 타입을 체크한 후 다운 캐스팅을 하는 코드를 작성하게 되는데 이런 방식은 런타임에 에러가 발생하는 원인이 됩니다. 추가적으로 코드가 장황해지는 문제점도 가지고 있습니다. 그래서 최대한 T 타입을 바짝 쪼아놓아야 런타임에 터지지 않고, 안전한 코드를 작성할 수 있습니다.

추가적으로 코틀린은 where 키워드를 사용해서 하나 이상의 제약을 둘 수 있습니다.

~~~java
class Cage2<T> where T : Animal, T : Comparable<T> {

	private val animals: MutableList<T> = mutableListOf()

}
~~~

## 실체화

자바 컴파일러는 타입 소거(Type Erasure)를 사용합니다. 컴파일 이후 제네릭 정보가 삭제되고 T 는 Object로 치환되고, 컴파일러가 다운 캐스팅을 하게 됩니다. 이는 실행 시점에는 제네릭 클래스의 인스턴스 타입을 알 수 없다는 의미입니다. 이는 메모리 사용량 면에서는 장점을 보이는데, 런타임 시점에서 List 안에있는 원소가 String인지 Int인지 알 수 있는 방법이 없습니다.

~~~java
// 컴파일 전
class Box <T> (
    private var value : T
) {

    fun set(obj : T) : Unit {
        this.value = obj
    }

    fun get() : T {
        return this.value
    }
}
~~~

~~~java
// 컴파일 후 
public final class Box {
   private Object value;

   public Box(Object value) {
      this.value = value;
   }

   public final void set(Object obj) {
      this.value = obj;
   }

   public final Object get() {
      return this.value;
   }
}
~~~

코틀린에서는 inline 키워드와 타입 파라미터를 reified로 지정해 런타임 시점에 타입을 검사할 수 있습니다. 

~~~java
inline fun <reified T> List<*>.hasAnyInstanceOf(): Boolean {
	return this.any { it is T }
}
~~~

왜냐하면 inline 함수는 컴파일 시점에 함수 본문을 바이트코드로 꼽아넣기 때문입니다. inline 함수를 사용하는 이유가 고차함수를 호출할 때 새로운 함수 객체를 생성하는 비용을 감소하기 위함도 있지만, 실체화를 통해 런타임에 타입 검사를 하기 위함도 있습니다. 주의할 점은 inline 함수가 뚱뚱해지면 오히려 성능 감소가 일어날 수 있는 것입니다. 함수의 크기를 체크하다가 너무 커지면 실체화한 타입에 의존하지 않는 부분을 일반 함수로 뽑아내라고 코틀린 인 액션 책에서 권장하고 있습니다.


## 변성(Variance)

> 변성 개념은 List<String>와 List<Any>와 같이 기저타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념입니다.

~~~java
fun main() {
    val goldFishCage = Cage2<GoldFish>()
    goldFishCage.put(GoldFish("금붕어"))

    val cage = Cage2<Fish>()
    cage.moveFrom(goldFishCage) // Type Missmatch
}
~~~

위의 코드에서 Type Missmatch가 발생하게 되는데 이는 Cage2<Fish>와 Cage2<GoldFish>가 아무런 상속 관계를 가지고 있지 않기 때문입니다. 코틀린에서 Number는 Int의 상위 타입이고, Int는 Number의 하위타입인 것을 알고 있으실 것입니다. Fish도 GoldFish의 상위 타입인데 Cage2<Fish>는 Cage2<GoldFish>의 상위 타입이 되어야 하는 것이 아닌가? 

타입 B인 변수를 타입 A인 것 처럼 사용할 수 있다면, B는 A의 서브타입이다. 위처럼 Number와 Int의 관계가 그렇습니다. 또, Int는 Int?의 서브타입입니다. 제네릭 클래스가 아닌 클래스에서는 클래스의 이름을 바로 타입으로 쓸 수 있습니다. 아래의 예시가 그렇습니다.

~~~java
var x: String
~~~

위처럼 변수를 선언하면 String 클래스의 인스턴스를 저장하는 변수를 정의할 수 있지만, var x: String? 처럼 같은 클래스 이름을 널이 될 수 있는 타입에도 쓸 수 있기 때문에 타입과 클래스는 일반적으로 다릅니다.

제네릭 클래스에서는 구체적인 타입을 얻으려면 T 타입을 구체적인 인자로 바꿔줘야 합니다. 예를 들어 List<Int>, List<String> 등이 있습니다. 



## 결론




