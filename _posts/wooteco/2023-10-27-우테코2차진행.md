---
published: false
title:  "Wooteco - 우테코 2차 프리코스 진행"
categories:
  - wooteco
---


# 커밋별 변경 내용과 근거
fix(README)
Car과 GameManager 객체만 생성
GameManager의 책임이 입력에 관한 책임들이 다수임. 근데 입력은 InputView가 책임을 가지면 될 듯.
따라서 GameManager는 InputView와 "협력" 관계로 매핑하면 될 듯.

---

10/26 (목)
우아한 객체지향 Youtube 시청 -> 이걸 2주차 프리코스 때 적용해보는 것도 좋겠다!
객체지향의 사실과 오해 Chapter 4 읽기 -> 협력, 책임, 역할


10/27 (금)
애플리케이션 아키텍처와 객체지향 Youtube 시청 -> 이것도 2주차 프리코스 때 적용해보는 것도 좋겠다!

2주차 프리코스 포크 뜨고 애플리케이션 아키텍처와 객체지향에서 본 것 적용
일단 기능 완성을 목표로 함(빠른 시간 내에) -> 2시간 안에 컷 함. -> 리팩토링 해야 함.
일단 기능 완성을 목표로 했지만 CRC Card를 이용해서 객체의 책임과 협력을 정해봄.
명사 추출(자동차, 우승자, 사용자, 입력, 출력) -> 자동차, GameManager, 우승자?의 Object, 책임, 협력 설계
1차 README 확인할 것..

Layer Architecture ??

아키텍처와 객체지향에 관한 글을 작성함.

10/28 (토)

MVC 패턴이 먼가 마음에 안듬. 일단 Browser와 Controller 와 매핑이되고 controller가 view와 매핑이되는데 다들 inputView에서 입력을 받음. 근데 내가 생각했을 때는 browser에서 이미 입력을 받은건데.. 
벨리데이션을 어디서 해야할까?

우창선배님이 남기신 옛날 프리코스 후기에서 많이 배우고 있습니다. 거기서 MVC 패턴 사진을 봤습니다.(사진은 아래와 같습니다) 

KEEPER R2 프로젝트에서 사용자 입력값을 Request DTO로 받고 컨트롤러에서 검증하는 과정은 위 사진과 유사해가지고 흐름이 이해가 됐습니다.

하지만 프리코스에서는 사용자의 입력값을 Scanner로 받을 수 밖에 없더라고요! 여기서 InputView의 역할이 무엇이고 위치가 왜 저기있는지 잘 모르곘습니다..ㅠㅠ

다들 InputView가 사용자의 입력값을 받고 검증을 해준다고 하는데 입력 값을 받는 과정은 Browser(Console)와 controller 사이에서 일어나야 한다고 생각하는데 InputView의 위치가 왜 Controller를 거치고 옆에 있는지 잘 모르겠습니다..

제가 생각한 view의 위치는 브라우저와 컨트롤러 사이에 있어야 한다고 생각했습니다. 그래서 1주차 때는 InputView라고 안 하고 InputUtil로 설정하고 컨트롤러에서 input 값을 받는 형식으로 미션을 제출했습니다.

선배님은 InputView의 역할이 무엇이고 위치가 어디에 있어야 한다고 생각하시나요? 제가 잘못 이해한 부분이 있나요?.?

---


허허 저희(저랑 우창이)도 똑같은 문제를 고민 했었는데요, 역시 우테코... 여전히 자세한 설명은 해주지 않는군요...
결론부터 말씀드리면 inputView는 브라우저 그 자체라고 생각하시면 됩니다. (저희 홈페이지 프로젝트에선 웹이죠)
이걸 이해하려면 왜 선배 개발자들이 3-tier layer(controller, service, repository)로 나눴는질 이해해야 하는데, 최소한 제가 이해하기론 변경에 유연하기 위해서입니다.
당연히 역할과 책임별로 나눈 이유도 있겠지만 "변경에 유연하기 위해서"라는 뜻은 어떤 layer에 변경사항이 있어도 그 변경이 다른 layer로 전파되는걸 막기 위해서인데요.
간단한 예시로 repository의 경우 DB와 통신하고 데이터를 가져오는 역할을 하는데, 만약 mysql에서 oracle로 저희가 DB를 바꾼다고 해서 service 코드나 controller 코드를 바꿀 필요는 없습니다.
그저 repository 코드만 oracle 문법으로 바꾸면 되죠.
다음 예시로 controller는 외부와 통신하는 역할을 합니다. 키퍼 홈페이지에선 웹으로 통신했고 보통 그렇게 통신하기 때문에 controller에 큰 변경은 항상 없어보이지만, 만약 키퍼 홈페이지가 shell을 지원해야 한다고 가정해봅시다.
그럼 이제 쉘 통신을 위해서 데이터를 주고 받는게 HTTP가 아니라 SSH나 다른 여러 방법으로 바뀌어야 할텐데, 그렇다고 service 코드가 바뀌진 않겠죠? (repository도)
이렇듯 선배 개발자들이 3-tier layer로 왜 나눴는지, 각각의 역할이 어떤건지 이해하셨다면 inputView가 어떤 역할인지 다시 한 번 보이실거에요.
inputView, outputView는 사용자와의 상호작용을 하는 역할을 가지고 있는데, 이는 우리 키퍼 홈페이지로 치면 웹 프론트와 비슷한 느낌이죠? 실제로 프론트에서 사용자와 상호작용을 하고 그 다음에 백엔드 controller layer로 데이터를 보내주니깐요.
그래서 inputView, outputView는 프론트라고 생각하면 편하실거에요.
 또 다음은 만약 콘솔로 입력을 받는 기능을 InputUtil로 만들고 Browser(콘솔)과 Controller 사이에 InputUtil을 끼워넣을려고 하면 중간 계층이 어떤게 있을까요? 언뜻 OSIV를 공부했을 때 FACADE 계층이 있었다는게 생각나서 찾아보니 그건 컨트롤러와 서비스 사이에 두는 계층이더라고요! application의 main 함수에서 컨트롤러 사이에 어떤 계층을 두는게 적당할까요??
위에서 말씀드린것처럼 콘솔 inputView, outputView가 프론트라는걸 이해하셨으면 Browser와 콘솔은 공존할 수 없다는걸 이해하실거에요. 왜냐면 둘 다 따지고 보면 사용자와 상호작용을 하는 프론트 layer 니까요.
그래서 콘솔 inputViewer, outputViewer를 -> 브라우저 inputViewer outputViewer로 대체할 순 있지만 함께 쓴다는건 mysql과 oracle을 동시에 같은 repository로 사용하겠다는 말과 비슷해요.
(쓸 순 있지만 repository를 분리해야겠죠? mysqlRepository, oracleRepository)



이건 순전히 제가 이해한 내용이고, 충분히 다른 의견이 있을 수도 있습니다. 왜냐면 애초에 3-tier layer라는건 너무 추상적이고 정의하기 나름이거든요.

---

또 다음은 만약 콘솔로 입력을 받는 기능을 InputUtil로 만들고 Browser(콘솔)과 Controller 사이에 InputUtil을 끼워넣을려고 하면 중간 계층이 어떤게 있을까요? 언뜻 OSIV를 공부했을 때 FACADE 계층이 있었다는게 생각나서 찾아보니 그건 컨트롤러와 서비스 사이에 두는 계층이더라고요! application의 main 함수에서 컨트롤러 사이에 어떤 계층을 두는게 적당할까요??

답변 정말로 감사드립니다~!! 선배님들도 똑같은 고민을 거치셨군요 ㅎㅎ

선배님 답변처럼 inputView를 브라우저 그 자체라고 생각하면 구조 이해가 정말 잘 되네요~~ 감사합니다!!

또 어제 조영호님이 애플리케이션 아키텍처와 객체지향 강의를 여러번 보면서 레이어에 관해서도 생각하고 글도 써봤는데 강의에서는 빵을 예시로 조금 추상적으로 설명해주셔서 ?? 했었는데 구체적인 예시로 설명해주셔가지고 이해가 훨씬 잘 됐습니다~~ 

답변해 주신 내용을 바탕으로 2주차 미션에서는 브라우저라고 생각하고 Viewer 계층을 둔 다음에 사용자와 상호작용할 수 있도록 미션 설계를 해보도록 하겠습니다..!!

항상 질문하면 얻어가는게 정말 많네요!! 정말 정말 감사드립니다 ㅠㅠㅠㅠ!!!

---

1차 검토

일단 Car 객체와 GameManager와 InputView, OutputView, 메시지 유틸 등의 객체를 만들고 역할과 책임을 부여했음.
근데 GameManager에 "무작위 값을 뽑아야 한다"라는 책임을 부여했는데 막상 기능을 만들고 검토를 해보니 GameManager의 존재도 까먹었고 책임도 부여하지 않음.
왜 이런 현상이 발생했는지 조금 생각을 해봤는데 "무작위 값을 뽑아야 한다"라는 책임은 메서드로 뽑아도 될 정도로 작은 기능이라서 Service 계층의 어플리케이션 로직을 처리할 때 같이 처리해버림. 그래서 GameManager 객체는 삭제함으로써 문제를 해결했습니다.

객체지향적인 설계를 하기위해서 조영호님 강의를 어제 봤었는데 CRC Card를 써서 객체의 협력, 책임, 역할을 부여하는데는 성공함. 그런데 레이어에 관한 부분이 매우 찝찝함.
일단 객체지향 설계를 하기 위해서는 핵심 도메인이 있어야 하고 도메인에게 데이터를 밀어넣으려면 Service 계층이 필요하다는 것은 내가 작성한 글에서 알 수 있음.
위에서 MVC 패턴에서 레이어에 관한 궁금증이 생겼고 선배님에게 질문함으로써 해결했음. 그래서 내가 생각하고 앞으로 미션을 진행하면서 적용해볼 레이어 구조는 아래와 같음

Viewer
Controller <--- apllication main
Service
Domain -> DAO

이렇게 구조를 다시 짜보고 리팩토링 해보자.

필드 주입으로 변경했는데 이건 나중에 고쳐야 할 듯.
Repositry를 싱글턴으로 보장해야 할 듯.
매직넘버, 매직 리터럴, 에러 세분화, 테스트 코드 작성 해야할 듯.

groubpingBy, Map.Entry.comparingByKey, Map.Entry::getValue -> ??

---

위에서 정한 레이어대로 코드를 리팩토링 함. 
하면서 절대적으로 지킨 것은 Service 레이어에서 View의 존재를 모르게 할 것.
컨트롤러는 View와 Service 레이어의 중간다리 역할을 충실히 할 것.
위의 이유는 1주차 프리코스 코드를 다시한번 봤을 때 Controller -> Service -> View 레이어의 흐름으로 이어졌습니다. 중간 창구 역할을 하는 Controller의 역할이 흐려진다는 느낌.
또 서비스는 어플리케이션 로직을 수행하고 결과 값을 리턴해주는(아래글 참고) 역할을 해야 하는데 View 레이어가 해야 하는 역할 까지도 가져가고 있어 경계가 모호해짐.
실제 프로젝트에서 이렇게 한다면 트랜잭션 범위가 View까지 물려버리기 떄문에 큰 장애가 일어날 수 있음.

그림 그려 볼것..

너무 억지로 역할을 쪼개지 말것. 위에서 봤을 때 CRC Card로 GameManager에게 책임을 할당 했는데 간단하게 Service 레이어에서 메서드로 추출한다면 더욱 쉽게 가져갈 수 있음.
괜히 오버헤드가 커짐



10/29 (일)

디펜던시 체크?

DAO 싱글턴으로

필드 인젝션 말고 생성자 주입으로 변경해보기

스프링 컨테이너를 직접 구현할 수 는 없나?


10/30 (월)

자잘한 메서드 명 변경: 단수 -> 복수
Stream으로 변경
매직 넘버 상수 처리
불필요한 주석 제거

10/31(화)

isEqualTo -> hasSize 수정
final 키워드 추가
private 메서드 순서 조정

--- 

READNE 수정하기
인터페이스로 발라내서 인터페이스에 의존하게 만들기 -> 아직 넘 어려움..ㅋㅋ;
Car Test 만들기 -> o

loopRacingCar -> 메서드 명이 실제 로직을 알려주고 있는 느낌 -> oo
그것보다는 도메인에 맞는 메서드 명으로 변경 -> oo
CarController가 두 가지 일을 함. -> 요거 변경

시도횟수 0 -> 예외 -> o 
이름 공백 -> 예외 -> o

CarRepositoryTest 변수명 수정 -> o

CarRepository Optional 반환 -> x

---

@BeforeEach로 반복되는 코드 줄이기

우테코에서 제공해준 테스트 코드 분석 및 글쓰기
Assertions.assertThatThrow 랑 차이점 비교

---
